// Execution Tree & Dependency Graph
// Separates collection structure (tree) from execution order (graph)

import type { Collection, Folder, Request, CollectionItem, IterationData, ILogger, PathType, NodeType, Auth } from '@apiquest/types';
import { LogLevel } from '@apiquest/types';
import { Logger } from './Logger.js';
import { isNullOrEmpty, isValidAuth } from './utils.js';

/**
 * Represents a node in the collection tree
 * - Tree structure: parent/children for hierarchical organization
 * - Graph structure: dependencies for execution order
 */
export class ExecutionNode {
  id: string;
  name: string;
  type: NodeType;
  item: Collection | Folder | Request;
  
  parent: ExecutionNode | null;
  children: ExecutionNode[];
  depth: number;
  path: PathType;
  
  /**
   * Scripts inherited from parent chain
   * Accumulated during tree construction for efficient execution
   */
  inheritedScripts: {
    collectionPre?: string;
    collectionPost?: string;
    folderPre?: string[];  // Outer to inner
    folderPost?: string[]; // Inner to outer (LIFO)
    preRequest?: string[];   // Collection → Folder → Request
    postRequest?: string[];  // Collection → Folder → Request, reverse for LIFO
  };
  
  /**
   * Effective auth for this node (cascades from parents)
   * Request auth > Folder auth > Parent folder auth > Collection auth
   */
  effectiveAuth?: Auth;
  
  // Execution control (requests only)
  condition?: string;
  dependsOn: string[];
  
  constructor(
    type: NodeType,
    item: Collection | Folder | Request,
    parent: ExecutionNode | null
  ) {
    this.type = type;
    this.item = item;
    this.parent = parent;
    this.children = [];
    this.depth = parent !== null ? parent.depth + 1 : 0;
    this.dependsOn = [];
    this.inheritedScripts = {};
    
    // Set ID and name
    if (type === 'collection') {
      this.id = (item as Collection).info.id;
      this.name = (item as Collection).info.name;
    } else {
      this.id = (item as Folder | Request).id;
      this.name = (item as Folder | Request).name;
    }
    
    // Build path using PathType format
    if (type === 'collection') {
      this.path = 'collection:/';
    } else if (parent?.type === 'collection') {
      // Direct child of collection
      this.path = `${type}:/${this.name}` as PathType;
    } else if (parent !== null) {
      // Nested within folders
      const basePath = parent.path.replace(/^(folder|request):\//, '');
      this.path = `${type}:/${basePath}/${this.name}` as PathType;
    } else {
      // Fallback (shouldn't happen)
      this.path = 'collection:/';
    }
    
    // Extract condition and dependencies (for requests)
    if (type === 'request') {
      const req = item as Request;
      this.condition = req.condition;
      this.dependsOn = req.dependsOn ?? [];
    }
    
    this.inheritScripts();
    this.inheritAuth();
  }
  
  /**
   * Accumulate scripts from parent chain
   * All scripts stack (collected from parents during tree construction)
   */
  private inheritScripts(): void {
    if (this.parent === null) return;
    
    this.inheritedScripts = {
      collectionPre: this.parent.inheritedScripts.collectionPre,
      collectionPost: this.parent.inheritedScripts.collectionPost,
      folderPre: this.parent.inheritedScripts.folderPre !== undefined ? [...this.parent.inheritedScripts.folderPre] : undefined,
      folderPost: this.parent.inheritedScripts.folderPost !== undefined ? [...this.parent.inheritedScripts.folderPost] : undefined,
      preRequest: this.parent.inheritedScripts.preRequest !== undefined ? [...this.parent.inheritedScripts.preRequest] : undefined,
      postRequest: this.parent.inheritedScripts.postRequest !== undefined ? [...this.parent.inheritedScripts.postRequest] : undefined
    };
    
    const parentItem = this.parent.item;
    
    if (this.parent.type === 'collection') {
      const coll = parentItem as Collection;
      if (!isNullOrEmpty(coll.collectionPreScript)) {
        this.inheritedScripts.collectionPre = coll.collectionPreScript;
      }
      if (!isNullOrEmpty(coll.collectionPostScript)) {
        this.inheritedScripts.collectionPost = coll.collectionPostScript;
      }
      if (!isNullOrEmpty(coll.preRequestScript)) {
        this.inheritedScripts.preRequest = this.inheritedScripts.preRequest ?? [];
        this.inheritedScripts.preRequest.push(coll.preRequestScript!);
      }
      if (!isNullOrEmpty(coll.postRequestScript)) {
        this.inheritedScripts.postRequest = this.inheritedScripts.postRequest ?? [];
        this.inheritedScripts.postRequest.unshift(coll.postRequestScript!);
      }
    }
    
    if (this.parent.type === 'folder') {
      const folder = parentItem as Folder;
      
      if (!isNullOrEmpty(folder.folderPreScript)) {
        this.inheritedScripts.folderPre = this.inheritedScripts.folderPre ?? [];
        this.inheritedScripts.folderPre.push(folder.folderPreScript!);
      }
      if (!isNullOrEmpty(folder.folderPostScript)) {
        this.inheritedScripts.folderPost = this.inheritedScripts.folderPost ?? [];
        this.inheritedScripts.folderPost.unshift(folder.folderPostScript!);
      }
      
      if (!isNullOrEmpty(folder.preRequestScript)) {
        this.inheritedScripts.preRequest = this.inheritedScripts.preRequest ?? [];
        this.inheritedScripts.preRequest.push(folder.preRequestScript!);
      }
      if (!isNullOrEmpty(folder.postRequestScript)) {
        this.inheritedScripts.postRequest = this.inheritedScripts.postRequest ?? [];
        this.inheritedScripts.postRequest.unshift(folder.postRequestScript!);
      }
    }
  }
  
  /**
   * Cascade auth from parent chain
   * Child auth overrides parent auth
   */
  private inheritAuth(): void {
    // Start with parent's effective auth
    if (this.parent?.effectiveAuth !== undefined) {
      this.effectiveAuth = this.parent.effectiveAuth;
    }
    
    // Override with this node's own auth if it has one
    if (this.type === 'collection') {
      const coll = this.item as Collection;
      if (isValidAuth(coll.auth)) {
        this.effectiveAuth = coll.auth;
      }
    } else {
      const folderOrRequest = this.item as Folder | Request;
      if (isValidAuth(folderOrRequest.auth)) {
        this.effectiveAuth = folderOrRequest.auth;
      }
    }
  }
  
  addChild(child: ExecutionNode): void {
    this.children.push(child);
  }
}

/**
 * Builds execution tree from collection JSON
 * Handles CLI --data override at construction time
 */
export class TreeBuilder {
  private cliData: IterationData[] | undefined;
  private logger: Logger;
  
  constructor(cliData?: IterationData[], logger?: ILogger) {
    this.cliData = cliData;
    this.logger = logger instanceof Logger ? logger : new Logger('TreeBuilder', LogLevel.INFO);
  }
  
  build(collection: Collection): ExecutionNode {
    this.logger.debug(`Building execution tree for collection: ${collection.info.name}`);
    
    if (this.cliData !== undefined && this.cliData.length > 0) {
      this.logger.debug(`Overriding collection testData with CLI data (${this.cliData.length} iterations)`);
      collection = { ...collection, testData: this.cliData };
    }
    
    const root = new ExecutionNode('collection', collection, null);
    this.buildChildren(root, collection.items);
    
    this.logger.debug(`Execution tree built: ${this.countNodes(root)} total nodes`);
    return root;
  }
  
  private buildChildren(parent: ExecutionNode, items: CollectionItem[]): void {
    for (const item of items) {
      const node = new ExecutionNode(item.type, item, parent);
      parent.addChild(node);
      
      this.logger.trace(`Added ${item.type} node: ${node.path}`);
      
      if (item.type === 'folder') {
        this.buildChildren(node, item.items);
      }
    }
  }
  
  private countNodes(node: ExecutionNode): number {
    let count = 1;
    for (const child of node.children) {
      count += this.countNodes(child);
    }
    return count;
  }
}

/**
 * Dependency graph for request execution order
 * Flattens tree to request nodes only, topologically sorted by dependencies
 */
export class DependencyGraph {
  private nodes: Map<string, ExecutionNode>;
  private edges: Map<string, Set<string>>;
  
  constructor(root: ExecutionNode, filterSet?: Set<string> | null) {
    this.nodes = new Map();
    this.edges = new Map();
    this.buildGraph(root, filterSet);
  }
  
  private buildGraph(node: ExecutionNode, filterSet?: Set<string> | null): void {
    if (node.type === 'request') {
      // Include request if no filter or if in filter set
      if (filterSet === null || filterSet === undefined || filterSet.has(node.id)) {
        this.nodes.set(node.id, node);
        // Filter dependencies to only include those in the graph
        const filteredDeps = filterSet === null || filterSet === undefined
          ? node.dependsOn
          : node.dependsOn.filter(depId => filterSet.has(depId));
        this.edges.set(node.id, new Set(filteredDeps));
      }
    }
    
    for (const child of node.children) {
      this.buildGraph(child, filterSet);
    }
  }
  
  /**
   * Topological sort: returns requests grouped by execution level
   * Requests in same level can execute in parallel
   */
  getExecutionLevels(): string[][] {
    const levels: string[][] = [];
    const remaining = new Set(this.nodes.keys());
    const completed = new Set<string>();
    
    while (remaining.size > 0) {
      const level: string[] = [];
      
      for (const nodeId of remaining) {
        const deps = this.edges.get(nodeId);
        if (deps === undefined) continue;
        
        const allDepsCompleted = Array.from(deps).every(dep => completed.has(dep));
        
        if (allDepsCompleted) {
          level.push(nodeId);
        }
      }
      
      if (level.length === 0 && remaining.size > 0) {
        throw new Error('Circular dependency detected');
      }
      
      for (const nodeId of level) {
        remaining.delete(nodeId);
        completed.add(nodeId);
      }
      
      if (level.length > 0) {
        levels.push(level);
      }
    }
    
    return levels;
  }
  
  getNode(id: string): ExecutionNode | undefined {
    return this.nodes.get(id);
  }
  
  canRunInParallel(idA: string, idB: string): boolean {
    const depsA = this.edges.get(idA);
    const depsB = this.edges.get(idB);
    
    return (depsA?.has(idB) ?? false) === false && (depsB?.has(idA) ?? false) === false;
  }
}
